我将整个开发过程拆解为 **8 个独立的任务**。您可以按照这个顺序，每次将一个任务的指令发送给大模型。这样可以确保每个模块都能在进入下一步之前独立运行且无 Bug。

---

### 任务 1：项目初始化与基础框架 (The Skeleton)
**目标**：搭建 React 环境，安装 UI 库，建立全局布局。
*   **输入给大模型的内容**：
    *   “请使用 React (Vite) + TypeScript 创建一个项目。”
    *   “安装 Material UI (MUI) 作为组件库。”
    *   “配置路由 (React Router)，包含首页、阅读页、单词本页、设置页。”
    *   “实现全局布局：左侧固定导航栏（Sidebar），右侧顶部搜索栏，中间内容区。”
    *   “在 `public/` 目录下预留 `videos/` 文件夹。”
*   **验收标准**：可以看到带有侧边栏的空白页面，点击菜单能切换路由。

### 任务 2：数据库层构建 (The Database)
**目标**：封装 IndexedDB，建立数据模型。
*   **输入给大模型的内容**：
    *   “请使用 `dexie.js` (推荐) 或 `idb` 库封装一个本地数据库服务。”
    *   “根据 PRD 中的 **数据模型 (Data Schema)** 部分，创建三张表：`settings`, `words`, `history`。”
    *   “编写基础的 CRUD 函数：`addWord`, `getAllWords`, `saveArticleRecord`, `getSettings`。”
    *   “编写一个 `seedDatabase` 函数，初始化时写入 50 个初中英语核心词汇作为测试数据。”
*   **验收标准**：控制台调用函数能成功读写数据，刷新页面数据不丢失。

### 任务 3：核心算法实现 (The Brain)
**目标**：实现艾宾浩斯记忆算法和选词逻辑（纯逻辑，暂不涉及 UI）。
*   **输入给大模型的内容**：
    *   “编写 `SRSAlgorithm.ts`：包含 `updateWordStatus(word, isCorrect)` 函数，实现 PRD 中 2.2 节的间隔重复逻辑（计算 next_review_at 和 interval）。”
    *   “编写 `WordSelector.ts`：实现 PRD 中 2.3 节的选词算法。输入总词数 N，输出一个单词列表（包含复习词、生词、熟词的比例逻辑）。”
*   **验收标准**：编写单元测试脚本，模拟用户答对/答错，检查单词的 `next_review_at` 时间戳计算是否正确。

### 任务 4：首页与手动选词交互 (The Dashboard)
**目标**：还原首页 UI，实现复杂的“手动/自动”选词弹窗。
*   **输入给大模型的内容**：
    *   “根据‘交互设计稿’还原首页 UI，包含核心卡片、记忆仪表盘（静态数据）、最近记录列表。”
    *   “实现‘自定义模式’弹窗：包含滑块（Slider）调整数量、单词标签云（Tag Cloud）支持删除。”
    *   “将弹窗与 **任务 3** 的选词算法连接：拖动滑块时，调用算法获取推荐词并在标签云中展示。”
*   **验收标准**：首页好看，点击“自定义”能弹出窗口，滑块能改变推荐的单词数量，点击 x 能删除单词。

### 任务 5：Deepseek API 服务层 (The Writer)
**目标**：封装 LLM 调用逻辑，处理 Prompt。
*   **输入给大模型的内容**：
    *   “封装 `LLMService.ts`。需要一个函数 `generateArticle(words[], length, userPref)`。”
    *   “编写 Prompt：重点要求 API 返回 **JSON 格式**（包含 `title`, `content`, `questions` 数组），而不是纯文本，方便前端解析。”
    *   “在开发阶段，为了省钱，请帮我写一个 `MockLLMService`，不调用真实 API，而是返回一段固定的假数据（包含文章和题目）用于测试 UI。”
*   **验收标准**：点击按钮，能打印出结构化的 JSON 文章和题目数据。

### 任务 6：文章阅读与考试页面 (The Core)
**目标**：展示文章，高亮单词，以及答题逻辑。
*   **输入给大模型的内容**：
    *   “开发 `ReadingPage`：左侧展示文章，核心词高亮（加粗）；右侧或底部展示题目。”
    *   “实现答题逻辑：用户选择选项后，判断对错。”
    *   “实现结算逻辑：答题完成后，计算得分，并调用 **任务 3** 的算法更新所有相关单词的状态。”
    *   “最后将本次记录保存到数据库。”
*   **验收标准**：流程跑通：生成 -> 阅读 -> 做题 -> 打分 -> 数据库中单词状态改变。

### 任务 7：全局查词与视频模块 (The Feature)
**目标**：实现单词详情弹窗和本地视频播放。
*   **输入给大模型的内容**：
    *   “实现全局组件 `WordDetailModal`。”
    *   “逻辑：当传入单词（如 'apple'）时，自动通过索引文件查找视频文件，然后播放视频中对应的时间段。如果视频文件不存在，显示‘暂无视频’的占位图。”
    *   “实现 HTML5 Video 播放器，如果视频加载失败（onError），显示‘暂无视频’的占位图。”
    *   “在顶部搜索栏和阅读页的单词点击事件中挂载此弹窗。”
*   **验收标准**：在阅读时点击单词，能弹出窗口；如果文件夹里放了视频，能正常播放。

### 任务 8：单词本与统计页 (The Review)
**目标**：数据展示与管理。
*   **输入给大模型的内容**：
    *   “开发单词本页面：列表展示所有单词，支持按状态（New/Review/Mastered）筛选。”
    *   “开发统计页面：使用简单的图表库（如 Recharts）展示近 7 天的学习时长和分数曲线。”
    *   “设置页：允许用户输入并保存 Deepseek API Key 到本地存储。”
*   **验收标准**：能看到所有单词的状态，能修改 API Key。

### 任务 9：真实数据导入 (The Real Data)
**目标**：导入 `zkgaopinci666.csv` 中的 666 个真实单词到数据库。
*   **输入给大模型的内容**：
    *   “请更新 `db.ts` 中的 `seedDatabase` 函数。”
    *   “读取 `public/cihuibiao/zkgaopinci666.csv` 文件（可以使用 `fetch` 或直接解析字符串）。”
    *   “解析 CSV 内容，将每一行映射为 `Word` 对象（spelling, meaning, phonetic）。”
    *   “将这 666 个单词批量写入 `words` 表（如果表为空）。”
*   **验收标准**：刷新页面，单词本中显示 666 个单词，且包含音标和释义。

### 任务 10：模拟视频索引更新 (The Index)
**目标**：更新 Mock 视频索引生成脚本，使其支持真实单词。
*   **输入给大模型的内容**：
    *   “请更新 `scripts/video_indexer/mock_gen.py`。”
    *   “读取 `public/cihuibiao/zkgaopinci666.csv` 获取真实单词列表。”
    *   “为这些单词生成模拟的 `video_map.json` 和 `index_*.json`。”
    *   “确保生成的索引文件覆盖所有 666 个单词，以便前端测试‘视频定位’功能（即使视频文件不存在）。”
*   **验收标准**：运行脚本后，在前端搜索任意一个真实单词（如 'ability'），能查到索引（虽然视频加载会失败并显示 Fallback UI）。 

---

### 给您的操作建议（Prompt 技巧）

在使用大模型执行这些任务时，建议遵循以下 **“三步走”** 模式：

1.  **投喂上下文**：
    *   在执行**任务 1** 时，把**完整的 PRD** 发给大模型，让它先理解整个项目。
    *   在执行后续任务（如任务 4）时，把**任务 1 和 2 生成的核心代码**（如数据模型定义）发给它，让它知道现有的代码结构。

2.  **要求 Mock 数据**：
    *   在前后端（API）联调前，始终要求大模型写 **Mock 数据**（假数据）。这样你不需要消耗 API Token 就能测试交互流程。

3.  **单文件原则**：
    *   如果可能，尽量让大模型一次只生成或修改 1-2 个文件，避免它一次性输出太多代码导致中断或逻辑混乱。

祝您的项目开发顺利！这个拆解方案应该能让大模型输出非常高质量的代码。